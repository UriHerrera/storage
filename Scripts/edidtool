#!/usr/bin/env python3

#############################################################################################################################################################################
#   The license used for this file and its contents is: BSD-3-Clause                                                                                                        #
#                                                                                                                                                                           #
#   Copyright <2025> <Uri Herrera <uri_herrera@nxos.org>>                                                                                                                   #
#                                                                                                                                                                           #
#   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:                          #
#                                                                                                                                                                           #
#    1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.                                        #
#                                                                                                                                                                           #
#    2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer                                      #
#       in the documentation and/or other materials provided with the distribution.                                                                                         #
#                                                                                                                                                                           #
#    3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software                    #
#       without specific prior written permission.                                                                                                                          #
#                                                                                                                                                                           #
#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,                      #
#    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS                  #
#    BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE                 #
#    GOODS OR SERVICES; LOSS OF USE, DATA,   OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,                      #
#    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   #
#############################################################################################################################################################################

import json
import hashlib
from pathlib import Path
import typer

app = typer.Typer(
    add_completion=False,
    help=(
        "EDIDTool — build and install EDID overrides that advertise VESA Adaptive-Sync.\n\n"
        "Typical use:\n"
        "  1. ./edidtool list                     → show all DRM connectors\n"
        "  2. ./edidtool dump --card card0 --connector DP-2\n"
        "  3. ./edidtool build --card card0 --connector DP-2 --out mi27-as.bin\n"
        "  4. sudo ./edidtool install --file mi27-as.bin --connector DP-2\n"
        "  5. Add the printed kernel parameter to your bootloader and reboot."
    ),
    rich_markup_mode="markdown"
)
__version__ = "1.1.1"

# ─────────────────────────── Core helpers ───────────────────────────
def rb(p: Path) -> bytes: return p.read_bytes()
def wb(p: Path, b: bytes) -> None:
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_bytes(b)

def split_blocks(edid: bytes) -> list[bytes]:
    if len(edid) < 128 or len(edid) % 128 != 0:
        raise RuntimeError("Invalid EDID size")
    return [edid[i:i+128] for i in range(0, len(edid), 128)]

def checksum128(b: bytes) -> int: return (-sum(b[:-1])) & 0xFF
def fix128(b: bytes) -> bytes:
    x = bytearray(b); x[-1] = 0; x[-1] = checksum128(bytes(x)); return bytes(x)

def make_displayid_as_ext(vmin: int, vmax: int) -> bytes:
    """Create a minimal DisplayID 1.3 block advertising Adaptive-Sync (48–165 Hz)."""
    ext = bytearray(128)
    ext[0:4] = bytes([0x70, 0x13, 0x00, 0x00])
    off = 4
    db = bytearray([0x12, 0x00, 0x0A, vmin & 0xFF, vmax & 0xFF,
                    0x00, 0x00, 0x00, 0x00, 0x01])
    ext[off:off + len(db)] = db
    ext = bytearray(fix128(bytes(ext)))
    return bytes(ext)

def append_ext(base: bytes, ext: bytes) -> bytes:
    blocks = split_blocks(base)
    b0 = bytearray(blocks[0])
    b0[0x7E] = (b0[0x7E] + 1) & 0xFF
    blocks[0] = fix128(bytes(b0))
    blocks.append(ext)
    return b"".join(blocks)

# ─────────────────────────── DRM connector helpers ───────────────────────────
def detect_connectors() -> list[dict]:
    root = Path("/sys/class/drm")
    items = []
    for p in root.glob("card*-*"):
        st = (p / "status").read_text().strip() if (p / "status").exists() else "unknown"
        items.append({
            "path": str(p),
            "card": p.name.split("-")[0],
            "connector": "-".join(p.name.split("-")[1:]),
            "status": st,
            "has_edid": (p / "edid").exists()
        })
    return sorted(items, key=lambda x: (x["card"], x["connector"]))

def pick_connector(card: str, connector: str) -> Path:
    p = Path(f"/sys/class/drm/{card}-{connector}")
    if not p.exists():
        raise RuntimeError(f"Connector not found: {card}-{connector}")
    if not (p / "edid").exists():
        raise RuntimeError(f"No EDID at {card}-{connector}")
    return p

# ─────────────────────────── Commands ───────────────────────────
@app.command(help="List all DRM connectors and whether an EDID is present.")
def list():
    typer.echo(json.dumps(detect_connectors(), indent=2))

@app.command(help="Dump the raw EDID from a connector to a file (default: ./edid.bin).")
def dump(
    card: str = typer.Option(..., help="Card name, e.g. card0"),
    connector: str = typer.Option(..., help="Connector name, e.g. DP-2"),
    out: Path = typer.Option(Path("./edid.bin"), help="Destination path for EDID dump")
):
    base = rb(pick_connector(card, connector) / "edid")
    wb(out, base)
    typer.echo(f"Saved EDID to {out}")

@app.command(help="Build a new EDID with Adaptive-Sync range appended.")
def build(
    card: str = typer.Option(..., help="Card name, e.g. card0"),
    connector: str = typer.Option(..., help="Connector name, e.g. DP-2"),
    out: Path = typer.Option(Path("./edid-as.bin"), help="Output file name"),
    vmin: int = typer.Option(48, help="Minimum VRR vertical frequency (Hz)"),
    vmax: int = typer.Option(165, help="Maximum VRR vertical frequency (Hz)")
):
    base = rb(pick_connector(card, connector) / "edid")
    ext = make_displayid_as_ext(vmin, vmax)
    ov = append_ext(base, ext)
    wb(out, ov)
    typer.echo(f"Wrote Adaptive-Sync EDID to {out}")

@app.command(help="Show file size, block count, and checksum for an EDID file.")
def info(file: Path = typer.Option(..., help="Path to EDID file")):
    b = rb(file)
    blocks = len(b) // 128
    sha = hashlib.sha256(b).hexdigest()
    typer.echo(json.dumps({"size": len(b), "blocks": blocks, "sha256": sha}, indent=2))

@app.command(help="Install an EDID file under /usr/lib/firmware/edid and print kernel parameters.")
def install(
    file: Path = typer.Option(..., help="EDID file to install"),
    connector: str = typer.Option(..., help="Connector name, e.g. DP-2"),
    fwdir: Path = typer.Option(Path("/usr/lib/firmware/edid"), help="Firmware directory (default: /usr/lib/firmware/edid)"),
    print_kernel_params: bool = typer.Option(True, help="Show boot parameters to enable override")
):
    data = rb(file)
    fwdir.mkdir(parents=True, exist_ok=True)
    target = fwdir / file.name
    wb(target, data)
    if print_kernel_params:
        typer.echo(f"\nAdd to kernel parameters:\n")
        typer.echo(f"  drm.edid_firmware={connector}:edid/{file.name}")
        typer.echo(f"  video={connector}:e\n")
    typer.echo(f"Installed {target}")

@app.callback()
def version_callback(
    version: bool = typer.Option(None, "--version", help="Show version and exit.", is_eager=True)
):
    if version:
        typer.echo(f"EDIDTool {__version__}")
        raise typer.Exit()

if __name__ == "__main__":
    app()
